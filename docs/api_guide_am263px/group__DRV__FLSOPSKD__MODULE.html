<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM263Px MCU+ SDK: APIs for FLSOPSKD</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM263Px MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM263Px MCU+ SDK
   &#160;<span id="projectnumber">11.01.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DRV__FLSOPSKD__MODULE.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle">
<div class="title">APIs for FLSOPSKD<div class="ingroups"><a class="el" href="group__DRV__MODULE.html">APIs for SOC Specific Device Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Introduction</h2>
<p>This module contains APIs for FLSOPSKD. FLSOPSKD stands for **FL**ash **OP**erations Scheduler (SKD)</p>
<p>FLSOPSKD is name given to 8051 controller that sits close to external flash controller (OSPI Controller) and monitors the traffic on the data bus. When there is no traffic on the OSPI data bus, 8051 will place the flash command on the bus. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFLSOPSKD__Params.html">FLSOPSKD_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2d498c04e33f417c40f404e70b7b5b2a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#ga2d498c04e33f417c40f404e70b7b5b2a">FLSOPSKD_usrGetTicks</a> ()</td></tr>
<tr class="memdesc:ga2d498c04e33f417c40f404e70b7b5b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">User defined getTicks function.  <a href="group__DRV__FLSOPSKD__MODULE.html#ga2d498c04e33f417c40f404e70b7b5b2a">More...</a><br /></td></tr>
<tr class="separator:ga2d498c04e33f417c40f404e70b7b5b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7121e1d21b5b05dca66fe104040850"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#ga0c7121e1d21b5b05dca66fe104040850">FLSOPSKD_Params_init</a> (<a class="el" href="structFLSOPSKD__Params.html">FLSOPSKD_Params</a> *pParams)</td></tr>
<tr class="memdesc:ga0c7121e1d21b5b05dca66fe104040850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init all params.  <a href="group__DRV__FLSOPSKD__MODULE.html#ga0c7121e1d21b5b05dca66fe104040850">More...</a><br /></td></tr>
<tr class="separator:ga0c7121e1d21b5b05dca66fe104040850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f456edc5e248c71a05d79f002e0e0b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#gaf3f456edc5e248c71a05d79f002e0e0b">FLSOPSKD_init</a> (<a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *pHandle, <a class="el" href="structFLSOPSKD__Params.html">FLSOPSKD_Params</a> *pParams)</td></tr>
<tr class="memdesc:gaf3f456edc5e248c71a05d79f002e0e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init the FLSOPSKD IP and driver.  <a href="group__DRV__FLSOPSKD__MODULE.html#gaf3f456edc5e248c71a05d79f002e0e0b">More...</a><br /></td></tr>
<tr class="separator:gaf3f456edc5e248c71a05d79f002e0e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dca857c5da40b01e6301a531acfcde"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#ga52dca857c5da40b01e6301a531acfcde">FLSOPSKD_write</a> (<a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *pHandle, uint32_t destAddr, uint8_t *pSrcBuffer, uint32_t bytesToWrite)</td></tr>
<tr class="memdesc:ga52dca857c5da40b01e6301a531acfcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends write scheduling request to hardware IP.  <a href="group__DRV__FLSOPSKD__MODULE.html#ga52dca857c5da40b01e6301a531acfcde">More...</a><br /></td></tr>
<tr class="separator:ga52dca857c5da40b01e6301a531acfcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2137274ca9bae35cca70370bd9606b11"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#ga2137274ca9bae35cca70370bd9606b11">FLSOPSKD_erase</a> (<a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *pHandle, uint32_t eraseOffsetInBytes)</td></tr>
<tr class="memdesc:ga2137274ca9bae35cca70370bd9606b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send erase scheduling request.  <a href="group__DRV__FLSOPSKD__MODULE.html#ga2137274ca9bae35cca70370bd9606b11">More...</a><br /></td></tr>
<tr class="separator:ga2137274ca9bae35cca70370bd9606b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53490f300196d955aebe615f0aa75f6e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#ga53490f300196d955aebe615f0aa75f6e">FLSOPSKD_getFwVersion</a> (<a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *pHandle, volatile uint32_t *pVersion)</td></tr>
<tr class="memdesc:ga53490f300196d955aebe615f0aa75f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Firmware version.  <a href="group__DRV__FLSOPSKD__MODULE.html#ga53490f300196d955aebe615f0aa75f6e">More...</a><br /></td></tr>
<tr class="separator:ga53490f300196d955aebe615f0aa75f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9489da27a842f6bdbec20b2a0dc131ec"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#ga9489da27a842f6bdbec20b2a0dc131ec">FLSOPSKD_busyPoll</a> (<a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *pHandle)</td></tr>
<tr class="memdesc:ga9489da27a842f6bdbec20b2a0dc131ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait till controller is busy.  <a href="group__DRV__FLSOPSKD__MODULE.html#ga9489da27a842f6bdbec20b2a0dc131ec">More...</a><br /></td></tr>
<tr class="separator:ga9489da27a842f6bdbec20b2a0dc131ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e504159f50987536a5fea126b59e763"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#ga3e504159f50987536a5fea126b59e763">FLSOPSKD_perfGetDowntime</a> (<a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *pHandle, uint32_t *memLoc)</td></tr>
<tr class="memdesc:ga3e504159f50987536a5fea126b59e763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get XIP downtime of last operation.  <a href="group__DRV__FLSOPSKD__MODULE.html#ga3e504159f50987536a5fea126b59e763">More...</a><br /></td></tr>
<tr class="separator:ga3e504159f50987536a5fea126b59e763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf09a320d94d8f6ea2d9ccd67beaddc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#gafbf09a320d94d8f6ea2d9ccd67beaddc">FLSOPSKD_perfGetPollCounts</a> (<a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *pHandle, uint32_t *memLoc)</td></tr>
<tr class="memdesc:gafbf09a320d94d8f6ea2d9ccd67beaddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Busy poll status count.  <a href="group__DRV__FLSOPSKD__MODULE.html#gafbf09a320d94d8f6ea2d9ccd67beaddc">More...</a><br /></td></tr>
<tr class="separator:gafbf09a320d94d8f6ea2d9ccd67beaddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0949b9f45290133aa74f6d1b76f4b87"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#gae0949b9f45290133aa74f6d1b76f4b87">FLSOPSKD_deinit</a> (<a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *pHandle)</td></tr>
<tr class="memdesc:gae0949b9f45290133aa74f6d1b76f4b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinit Handle.  <a href="group__DRV__FLSOPSKD__MODULE.html#gae0949b9f45290133aa74f6d1b76f4b87">More...</a><br /></td></tr>
<tr class="separator:gae0949b9f45290133aa74f6d1b76f4b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4913bdaecf926592ec6ce0272bf6d209"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DRV__FLSOPSKD__MODULE.html#ga4913bdaecf926592ec6ce0272bf6d209">FLSOPSKD_EXPECTED_FW_VERSION</a>&#160;&#160;&#160;(0x10000U)</td></tr>
<tr class="memdesc:ga4913bdaecf926592ec6ce0272bf6d209"><td class="mdescLeft">&#160;</td><td class="mdescRight">The version number that this driver expects from the firmware running in 8051.  <a href="group__DRV__FLSOPSKD__MODULE.html#ga4913bdaecf926592ec6ce0272bf6d209">More...</a><br /></td></tr>
<tr class="separator:ga4913bdaecf926592ec6ce0272bf6d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4913bdaecf926592ec6ce0272bf6d209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4913bdaecf926592ec6ce0272bf6d209">&#9670;&nbsp;</a></span>FLSOPSKD_EXPECTED_FW_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLSOPSKD_EXPECTED_FW_VERSION&#160;&#160;&#160;(0x10000U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The version number that this driver expects from the firmware running in 8051. </p>
<p>It is good practice to get the firmware version from 8051 and check if it is equal to this macro. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2d498c04e33f417c40f404e70b7b5b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d498c04e33f417c40f404e70b7b5b2a">&#9670;&nbsp;</a></span>FLSOPSKD_usrGetTicks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t FLSOPSKD_usrGetTicks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User defined getTicks function. </p>
<p>User should define this function in their applicaiton.</p>
<dl class="section return"><dt>Returns</dt><dd>system ticks </dd></dl>

</div>
</div>
<a id="ga0c7121e1d21b5b05dca66fe104040850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c7121e1d21b5b05dca66fe104040850">&#9670;&nbsp;</a></span>FLSOPSKD_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Params.html">FLSOPSKD_Params</a> *&#160;</td>
          <td class="paramname"><em>pParams</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init all params. </p>
<p>Use this function to initilize the parameters. if <a class="el" href="structFLSOPSKD__Params.html#a4ff6b33c59674a9e89be3629c9390a68">FLSOPSKD_Params.pageSizeInBytes</a> is 0 then this function sets it to 256. if <a class="el" href="structFLSOPSKD__Params.html#a00b4c8f4e578187d10e33652329ef540">FLSOPSKD_Params.eraseSizeInBytes</a> is 0 then this function sets it to 4096. if <a class="el" href="structFLSOPSKD__Params.html#aa1731696be10ecdada90e051918f78eb">FLSOPSKD_Params.eraseOpCode</a> is 0 then this function sets it to 0x21. if <a class="el" href="structFLSOPSKD__Params.html#a513b1804828573c76f057941947c17f6">FLSOPSKD_Params.eraseExOpCode</a> is 0 then this function sets it to 0x21. <a class="el" href="structFLSOPSKD__Params.html#a78d0bbb3ceaadba4caef496b7fe86ac6">FLSOPSKD_Params.pollTimeout</a> is set to 1000.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pParams</td><td>pointer to <a class="el" href="structFLSOPSKD__Params.html">FLSOPSKD_Params</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
<a id="gaf3f456edc5e248c71a05d79f002e0e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3f456edc5e248c71a05d79f002e0e0b">&#9670;&nbsp;</a></span>FLSOPSKD_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Params.html">FLSOPSKD_Params</a> *&#160;</td>
          <td class="paramname"><em>pParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init the FLSOPSKD IP and driver. </p>
<p>FLSOPSKD IP is initilized by following procedure:</p><ol type="1">
<li>Put 8051 in reset state</li>
<li>Enable and initilize 8051 memory<ol type="a">
<li>This step consist of enabling R5F access to 8051 code and data access.</li>
<li>wait for memory to finish initilization</li>
</ol>
</li>
<li>Load 8051 firmware in the 8051 code/data memory.</li>
<li>Disable R5F access to 8051 memories to avoid unintentional modification of 8051 firmware.</li>
<li>Enable required interrupts in the IP and R5F.</li>
<li>Lift 8051 from reset</li>
</ol>
<p>Most of the flash paramter are taken from the OSPI IP. However, some other parameter of external flash are not save in the OSPI IP and those needs to be save in the RAM. eraseOpCode and eraseExOpCode are such flash parameters and all of these parameters are in pParams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>[in] pointer to <a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> instance. </td></tr>
    <tr><td class="paramname">pParams</td><td>pointer to <a class="el" href="structFLSOPSKD__Params.html">FLSOPSKD_Params</a> Object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
<a id="ga52dca857c5da40b01e6301a531acfcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52dca857c5da40b01e6301a531acfcde">&#9670;&nbsp;</a></span>FLSOPSKD_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pSrcBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytesToWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends write scheduling request to hardware IP. </p>
<p>This function will schedule a write command to the flash and sends that command as soon as the OSPI Bus is free. After M8051 sends the write command, it also polls for the completion of write. Completion of write is logically determined by the <code>m8051 done</code> interrupt which is set only after the WIP bit of the external flash is not active.</p>
<p>SOC memory-map maps flash to some address space, for example, 0x60000000 and suppose application wants to write to 0x60000000 + 1MB = 0x60100000. In this case, destAddr should be 0x100000 and not 0x60100000.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>[in] pointer to <a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> instance. </td></tr>
    <tr><td class="paramname">destAddr</td><td>[in] Flash address to which to write this buffer </td></tr>
    <tr><td class="paramname">pSrcBuffer</td><td>[in] pointer to source buffer </td></tr>
    <tr><td class="paramname">bytesToWrite</td><td>[in] size of the buffer to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
<a id="ga2137274ca9bae35cca70370bd9606b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2137274ca9bae35cca70370bd9606b11">&#9670;&nbsp;</a></span>FLSOPSKD_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eraseOffsetInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send erase scheduling request. </p>
<p>This function schedules erase command and sends it to the flash as soon as the OSPI lines are free. This function also polls by sending the status check commands and if polling is enabled then will only return when the flash WIP bit is not active.</p>
<p>The command which is sent to the external flash requries a field called address. This field specifies the sector/block which is to be erased. Depending on flash, its value can be constraint. Value of that field is sent via eraseOffsetInBytes argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>[in] pointer to <a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> instance. </td></tr>
    <tr><td class="paramname">eraseOffsetInBytes</td><td>[in] block offset in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
<a id="ga53490f300196d955aebe615f0aa75f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53490f300196d955aebe615f0aa75f6e">&#9670;&nbsp;</a></span>FLSOPSKD_getFwVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_getFwVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>pVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Firmware version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>[in] pointer to <a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> instance. </td></tr>
    <tr><td class="paramname">pVersion</td><td>[out] pointer to memory to save version info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
<a id="ga9489da27a842f6bdbec20b2a0dc131ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9489da27a842f6bdbec20b2a0dc131ec">&#9670;&nbsp;</a></span>FLSOPSKD_busyPoll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_busyPoll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait till controller is busy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>[in] pointer to <a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
<a id="ga3e504159f50987536a5fea126b59e763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e504159f50987536a5fea126b59e763">&#9670;&nbsp;</a></span>FLSOPSKD_perfGetDowntime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_perfGetDowntime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>memLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get XIP downtime of last operation. </p>
<p>Each Flash operation cause some downtime of XIP. After operation is complete, the FLSOPSKD firmware returns the worst case XIP downtime that application can expect out of the last operation. This function returns the XIP downtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>[in] pointer to <a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> instance. </td></tr>
    <tr><td class="paramname">memLoc</td><td>[out] pointer to location to write the downtime. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
<a id="gafbf09a320d94d8f6ea2d9ccd67beaddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbf09a320d94d8f6ea2d9ccd67beaddc">&#9670;&nbsp;</a></span>FLSOPSKD_perfGetPollCounts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_perfGetPollCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>memLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Busy poll status count. </p>
<p>After sending any erase or write operation, FLSOPSKD operation also sends status operation. After the operation is complete, the number of status polls sent is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>[in] pointer to <a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> instance. </td></tr>
    <tr><td class="paramname">memLoc</td><td>[out] pointer to location to write polls count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
<a id="gae0949b9f45290133aa74f6d1b76f4b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0949b9f45290133aa74f6d1b76f4b87">&#9670;&nbsp;</a></span>FLSOPSKD_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t FLSOPSKD_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> *&#160;</td>
          <td class="paramname"><em>pHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinit Handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandle</td><td>[in] pointer to <a class="el" href="structFLSOPSKD__Handle.html">FLSOPSKD_Handle</a> instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SystemP_FAILURE </dd>
<dd>
SystemP_SUCCESS </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
