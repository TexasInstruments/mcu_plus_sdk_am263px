<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>AM263Px MCU+ SDK: ICSS EMAC Queue Management Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="AM263Px MCU+ SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AM263Px MCU+ SDK
   &#160;<span id="projectnumber">11.00.00</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ICSS_EMAC_QUEUE_MANAGEMENT_DESIGN.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ICSS EMAC Queue Management Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md1378">Overview</a></li>
<li class="level1"><a href="#autotoc_md1379">Ports in ICSS EMAC</a></li>
<li class="level1"><a href="#autotoc_md1380">Port-Based Queue Organization</a><ul><li class="level2"><a href="#autotoc_md1381">Queue Distribution</a></li>
<li class="level2"><a href="#autotoc_md1382">Default Queue Sizes</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1383">Introduction to Queue Management Units</a><ul><li class="level2"><a href="#autotoc_md1384">Buffer</a></li>
<li class="level2"><a href="#autotoc_md1385">Buffer Descriptor (BD)</a></li>
<li class="level2"><a href="#autotoc_md1386">Queue</a></li>
<li class="level2"><a href="#autotoc_md1387">Queue Descriptor (QD)</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1388">Detailed Component Structure and Relationships</a></li>
<li class="level1"><a href="#autotoc_md1389">Collision Queue</a><ul><li class="level2"><a href="#autotoc_md1390">What is Queue Contention?</a></li>
<li class="level2"><a href="#autotoc_md1391">Primary-Secondary Arbitration System</a></li>
<li class="level2"><a href="#autotoc_md1392">How the Arbitration Works</a></li>
<li class="level2"><a href="#autotoc_md1393">Collision Queue Mechanism</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1394">Reception Flow Example</a><ul><li class="level2"><a href="#autotoc_md1395">Initial State (Empty Queues)</a></li>
<li class="level2"><a href="#autotoc_md1396">Packet Arrives at PRU (Firmware Receives)</a></li>
<li class="level2"><a href="#autotoc_md1397">Firmware (Producer) Actions</a></li>
<li class="level2"><a href="#autotoc_md1398">Host (Consumer) Actions</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md1399">Transmission Flow Example</a><ul><li class="level2"><a href="#autotoc_md1400">Initial State (Empty Transmit Queue)</a></li>
<li class="level2"><a href="#autotoc_md1401">Application Calls ICSS_EMAC_txPacket</a></li>
<li class="level2"><a href="#autotoc_md1402">Driver (Producer) Actions in ICSS_EMAC_txPacketEnqueue</a></li>
<li class="level2"><a href="#autotoc_md1403">Firmware (Consumer) Actions</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_components_networking_icss_emac_icss_emac_queue_management"></a></p>
<h1><a class="anchor" id="autotoc_md1378"></a>
Overview</h1>
<p>This page describes the queue management implementation in the ICSS EMAC driver. The queue management system is responsible for managing the flow of packets between the PRU firmware and the host processor.</p>
<h1><a class="anchor" id="autotoc_md1379"></a>
Ports in ICSS EMAC</h1>
<p>The ICSS-EMAC architecture uses a specific port numbering convention that is fundamental to understanding queue management. Although there are only two physical Ethernet ports on every ICSS instance, the system treats the host processor as a logical third port for convenience and protocol compatibility.</p>
<p>The ports are referred to as:</p><ul>
<li>Host Port (in Switch mode): <a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga529426b030d582d0589f29b064643cd6">ICSS_EMAC_PORT_0</a></li>
<li>Physical Port 0: <a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga8149aef84e214698f4c40e3a6290cab1">ICSS_EMAC_PORT_1</a></li>
<li>Physical Port 1: <a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga8961b5fbf7d921e0f2869d85386e0df3">ICSS_EMAC_PORT_2</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md1380"></a>
Port-Based Queue Organization</h1>
<p>Each port has its own set of queues, and the total number varies by operating mode.</p>
<h2><a class="anchor" id="autotoc_md1381"></a>
Queue Distribution</h2>
<p><b>Switch Mode</b>: 15 queues total</p><ul>
<li>4 host receive queues (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga529426b030d582d0589f29b064643cd6">ICSS_EMAC_PORT_0</a>)</li>
<li>4 transmit queues for Physical Port 0 (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga8149aef84e214698f4c40e3a6290cab1">ICSS_EMAC_PORT_1</a>)</li>
<li>4 transmit queues for Physical Port 1 (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga8961b5fbf7d921e0f2869d85386e0df3">ICSS_EMAC_PORT_2</a>)</li>
<li>3 collision queues (1 per port)</li>
</ul>
<p><b>EMAC Mode</b>: 12 queues total</p><ul>
<li>2 host receive queues for Physical Port 0 (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga529426b030d582d0589f29b064643cd6">ICSS_EMAC_PORT_0</a>)</li>
<li>2 host receive queues for Physical Port 1 (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga529426b030d582d0589f29b064643cd6">ICSS_EMAC_PORT_0</a>)</li>
<li>4 transmit queues for Physical Port 0 (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga8149aef84e214698f4c40e3a6290cab1">ICSS_EMAC_PORT_1</a>)</li>
<li>4 transmit queues for Physical Port 1 (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga8961b5fbf7d921e0f2869d85386e0df3">ICSS_EMAC_PORT_2</a>)</li>
<li>No collision queues (due to independent operation)</li>
</ul>
<p>Each queue is a block of memory used to store packet data. Queue sizes may vary and are configurable using <a class="el" href="structICSS__EMAC__FwDynamicMmap.html">ICSS_EMAC_FwDynamicMmap</a> (which is a member of <a class="el" href="structICSS__EMAC__Params.html">ICSS_EMAC_Params</a> passed while calling <a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga3dfa23ace97b9812cbc71184186b8e52">ICSS_EMAC_open</a>).</p>
<div class="image">
<img src="ICSS_EMAC_Queues.PNG" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md1382"></a>
Default Queue Sizes</h2>
<p>The default queue sizes are shown below. The sizes are denoted by blocks, where each block is 32 bytes in size.</p>
<div class="fragment"><div class="line"><span class="comment">/* Physical Port queue size. Same for both ports */</span></div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_QUEUE_1_SIZE        ((uint32_t)97U)       </span><span class="comment">/* Network Management high */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_QUEUE_2_SIZE        ((uint32_t)97U)       </span><span class="comment">/* Network Management low */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_QUEUE_3_SIZE        ((uint32_t)97U)       </span><span class="comment">/* Protocol specific */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_QUEUE_4_SIZE        ((uint32_t)97U)       </span><span class="comment">/* NRT (IP,ARP, ICMP, ?) */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/* HOST PORT QUEUES can buffer up to 4 full sized frames per queue */</span></div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_HOST_QUEUE_1_SIZE   ((uint32_t)194U)      </span><span class="comment">/* Protocol and/or VLAN priority 7 and 6 */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_HOST_QUEUE_2_SIZE   ((uint32_t)194U)      </span><span class="comment">/* Protocol mid */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_HOST_QUEUE_3_SIZE   ((uint32_t)194U)      </span><span class="comment">/* Protocol low */</span><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_HOST_QUEUE_4_SIZE   ((uint32_t)194U)      </span><span class="comment">/* NRT (IP, ARP, ICMP ?) */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define ICSS_EMAC_DEFAULT_FW_COLLISION_QUEUE_SIZE (48U)</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1383"></a>
Introduction to Queue Management Units</h1>
<h2><a class="anchor" id="autotoc_md1384"></a>
Buffer</h2>
<p>A buffer is the actual memory space where packet data is stored.</p>
<ul>
<li><b>Size</b>: Fixed 32-byte blocks</li>
<li><b>Location</b>: Stored in MSRAM</li>
<li><b>Content</b>: Raw Ethernet packet data</li>
<li><b>Alignment</b>: 32-byte aligned</li>
</ul>
<p>Buffers are stored in memory starting at the offset: <code>icssEmacHandle-&gt;attrs-&gt;l3OcmcBaseAddr + rxQueue-&gt;buffer_offset</code></p>
<p>The start MSRAM address where the packet content is actually stored is calculated by the driver via: <code>icssEmacHandle-&gt;attrs-&gt;l3OcmcBaseAddr + rxQueue-&gt;buffer_offset + buffer_desc_num</code></p>
<p><b>Buffer Example (32 bytes of packet data):</b></p>
<div class="fragment"><div class="line">┌──────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Ethernet Header      | IP Header (partial) | Data continues  │</div>
<div class="line">│ (14 bytes)           | (18 bytes)          | in next buffer  │</div>
<div class="line">└──────────────────────────────────────────────────────────────┘</div>
<div class="line">│◄──────────────────── 32 bytes total ───────────────────────►│</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>A single buffer holds exactly 32 bytes. If a packet is larger, it spans multiple buffers. For example, a typical Ethernet frame with headers would need multiple 32-byte buffers to store the complete packet.</dd></dl>
<h2><a class="anchor" id="autotoc_md1385"></a>
Buffer Descriptor (BD)</h2>
<p>A buffer descriptor is metadata that describes and points to buffer(s) containing packet data.</p>
<ul>
<li><b>Size</b>: 32 bits (4 bytes) per descriptor</li>
<li><b>Location</b>: Stored in ICSS Shared RAM in a contiguous manner</li>
<li><b>Purpose</b>: Contains packet metadata and buffer management info</li>
<li><b>Relationship</b>: Multiple BDs can point to different 32-byte blocks of the same packet</li>
</ul>
<p>BDs are stored in memory starting at the offset: <code>ICSS_EMAC_QueueParams *rxQueue = icssEmacHandle-&gt;object-&gt;switchPort[ICSS_EMAC_PORT_0]-&gt;queue[x]-&gt;buffer_desc_offset</code></p>
<p>For calculating the first buffer descriptor corresponding to a packet, the driver does the following: <code>buffer_desc_num = (queue_rd_ptr - rxQueue-&gt;buffer_desc_offset) / (ICSS_EMAC_DEFAULT_FW_BD_SIZE (4))</code></p>
<p><b>Buffer Descriptor Structure (32-bit):</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Bit 31  </th><th class="markdownTableHeadNone">Bit 30  </th><th class="markdownTableHeadNone">Bit 29  </th><th class="markdownTableHeadNone">Bits 28-18  </th><th class="markdownTableHeadNone">Bits 17-16  </th><th class="markdownTableHeadNone">Bits 15-0   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Error Flag  </td><td class="markdownTableBodyNone">Broadcast Flag  </td><td class="markdownTableBodyNone">VLAN Tag  </td><td class="markdownTableBodyNone">Length (11 bits)  </td><td class="markdownTableBodyNone">Port (2 bits)  </td><td class="markdownTableBodyNone">Unused/Protocol Specific   </td></tr>
</table>
<p><b>Example: 100-byte packet needs 4 buffer descriptors:</b></p>
<div class="fragment"><div class="line">Packet (100 bytes) split across buffers:</div>
<div class="line">┌────────────────────┬────────────────────┬────────────────────┬────────────────────┐</div>
<div class="line">│ BD1 → Buffer1 (32B)│ BD2 → Buffer2 (32B)│ BD3 → Buffer3 (32B)│ BD4 → Buffer4 (4B) │</div>
<div class="line">│ [Length=100]       │ [Length=0]         │ [Length=0]         │ [Length=0]         │</div>
<div class="line">│ [Port=1]           │ [Port=0]           │ [Port=0]           │ [Port=0]           │</div>
<div class="line">│ [Error=0]          │ [Error=0]          │ [Error=0]          │ [Error=0]          │</div>
<div class="line">└────────────────────┴────────────────────┴────────────────────┴────────────────────┘</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The first BD contains the complete packet length and metadata, while subsequent BDs point to additional 32-byte data blocks.</dd></dl>
<h2><a class="anchor" id="autotoc_md1386"></a>
Queue</h2>
<p>A queue is a logical collection of buffers organized to store multiple packets in a FIFO manner.</p>
<ul>
<li><b>Organization</b>: Circular buffer structure</li>
<li><b>Capacity</b>: Configurable size in terms of 32-byte blocks</li>
<li><b>Types</b>: Host receive queues, Port transmit queues, Collision queues</li>
<li><b>Priority</b>: 4 priority levels per port (Queue 0=highest, Queue 3=lowest)</li>
<li><b>Location</b>: Stored in MSRAM</li>
</ul>
<p><b>Queue Structure (Logical View):</b></p>
<div class="fragment"><div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Queue N (e.g., P0_Q1)                                       │</div>
<div class="line">├─────────────────────────────────────────────────────────────┤</div>
<div class="line">│ Packet 1 Buffers:                                           │</div>
<div class="line">│ ┌──────┐ ┌──────┐ ┌──────┐                                  │</div>
<div class="line">│ │Buffer│ │Buffer│ │Buffer│                                  │</div>
<div class="line">│ │  1   │ │  2   │ │  3   │                                  │</div>
<div class="line">│ │ 32B  │ │ 32B  │ │  4B  │                                  │</div>
<div class="line">│ └──────┘ └──────┘ └──────┘                                  │</div>
<div class="line">│                                                             │</div>
<div class="line">│ Packet 2 Buffers:                                           │</div>
<div class="line">│ ┌──────┐ ┌──────┐                                           │</div>
<div class="line">│ │Buffer│ │Buffer│                                           │</div>
<div class="line">│ │  4   │ │  5   │                                           │</div>
<div class="line">│ │ 32B  │ │ 32B  │                                           │</div>
<div class="line">│ └──────┘ └──────┘                                           │</div>
<div class="line">│                                                             │</div>
<div class="line">│ ... (more packets)                                          │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1387"></a>
Queue Descriptor (QD)</h2>
<p>A queue descriptor is the control structure that manages a queue's state and pointers.</p>
<ul>
<li><b>Size</b>: 64 bits (8 bytes) per descriptor</li>
<li><b>Location</b>: Stored in ICSS Data RAM 1 (Switch Mode) or ICSS Shared RAM (EMAC Mode)</li>
<li><b>Purpose</b>: Tracks queue fill level, read/write positions, and status</li>
<li><b>Shared</b>: Accessed by both PRU firmware and host driver</li>
</ul>
<p><b>Queue Descriptor Fields:</b></p>
<ul>
<li><b>Rd_ptr</b>: Read pointer - Points to the next buffer descriptor to be read by the driver/host. Driver increments this after reading data.</li>
<li><b>Wr_ptr</b>: Write pointer - Points to the next buffer descriptor where firmware will write new data. Firmware increments this after writing new data. When read pointer equals write pointer, queue is empty.</li>
<li><b>busy_s</b>: Driver sets when copying data (prevents firmware corruption)</li>
<li><b>status</b>: Queue operational status</li>
<li><b>max_fill_level</b>: Peak queue utilization in bytes</li>
<li><b>overflow_cnt</b>: Number of overflow events</li>
</ul>
<p>For switch mode, the QDs are stored starting at offset: <code>pruicssHwAttrs-&gt;pru1DramBase + pStaticMMap-&gt;p0QueueDescOffset</code></p>
<p>For checking the various QDs in Switch mode, the driver accesses them via: <code>pruicssHwAttrs-&gt;pru1DramBase + pStaticMMap-&gt;p0QueueDescOffset + (queueNum * ICSS_EMAC_DEFAULT_FW_QD_SIZE (8))</code></p>
<p><b>Queue Descriptor Structure (64-bit):</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Bits 63-56  </th><th class="markdownTableHeadNone">Bits 55-48  </th><th class="markdownTableHeadNone">Bits 47-40  </th><th class="markdownTableHeadNone">Bits 39-32  </th><th class="markdownTableHeadNone">Bits 31-16  </th><th class="markdownTableHeadNone">Bits 15-0   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">overflow_cnt  </td><td class="markdownTableBodyNone">max_fill_level  </td><td class="markdownTableBodyNone">status  </td><td class="markdownTableBodyNone">busy_s  </td><td class="markdownTableBodyNone">wr_ptr  </td><td class="markdownTableBodyNone">rd_ptr   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md1388"></a>
Detailed Component Structure and Relationships</h1>
<p>The following diagram shows the hierarchical relationship between all queue management components:</p>
<div class="fragment"><div class="line">┌────────────────────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Component Detailed Structure                                               │</div>
<div class="line">├────────────────────────────────────────────────────────────────────────────┤</div>
<div class="line">│                                                                            │</div>
<div class="line">│ ┌────────────────────────────────────────────────────────────────────────┐ │</div>
<div class="line">│ │ QUEUE (Logical Entity)                                                 │ │</div>
<div class="line">│ │ ┌────────────────────────────────────────────────────────────────────┐ │ │</div>
<div class="line">│ │ │ Purpose: Organize multiple packets in FIFO order                   │ │ │</div>
<div class="line">│ │ │ Types: Host Rx (4), Port1 Tx (4), Port2 Tx (4), Collision (3)      │ │ │</div>
<div class="line">│ │ │ Organization: Circular buffer with configurable size               │ │ │</div>
<div class="line">│ │ │ Priority: 0=Highest (Network Mgmt), 3=Lowest (NRT)                 │ │ │</div>
<div class="line">│ │ └────────────────────────────────────────────────────────────────────┘ │ │</div>
<div class="line">│ │                           │                                            │ │</div>
<div class="line">│ │                           │ Managed by                                 │ │</div>
<div class="line">│ │                           ▼                                            │ │</div>
<div class="line">│ │ ┌────────────────────────────────────────────────────────────────────┐ │ │</div>
<div class="line">│ │ │ QUEUE DESCRIPTOR (Control Structure)                               │ │ │</div>
<div class="line">│ │ │ Location: PRU1 Data RAM (Switch) / Shared RAM (EMAC)               │ │ │</div>
<div class="line">│ │ │ Size: 64 bits (8 bytes)                                            │ │ │</div>
<div class="line">│ │ │ ┌────────────────────────────────────────────────────────────────┐ │ │ │</div>
<div class="line">│ │ │ │ Bits 63-56   |  55-48   |  47-40 | 39-32  |  31-16 |  15-0     │ │ │ │</div>
<div class="line">│ │ │ │ overflow_cnt | max_fill | status | busy_s | Wr_ptr | Rd_ptr    │ │ │ │</div>
<div class="line">│ │ │ └────────────────────────────────────────────────────────────────┘ │ │ │</div>
<div class="line">│ │ │ • Rd_ptr: Next BD to be read by driver (consumer pointer)          │ │ │</div>
<div class="line">│ │ │ • Wr_ptr: Next BD for firmware to write (producer pointer)         │ │ │</div>
<div class="line">│ │ │ • busy_s: Driver sets during data copy operations                  │ │ │</div>
<div class="line">│ │ │ • Queue Empty: Rd_ptr == Wr_ptr                                    │ │ │</div>
<div class="line">│ │ └────────────────────────────────────────────────────────────────────┘ │ │</div>
<div class="line">│ │                           │                                            │ │</div>
<div class="line">│ │                           │ Points to                                  │ │</div>
<div class="line">│ │                           ▼                                            │ │</div>
<div class="line">│ │ ┌────────────────────────────────────────────────────────────────────┐ │ │</div>
<div class="line">│ │ │ BUFFER DESCRIPTORS (Packet Metadata)                               │ │ │</div>
<div class="line">│ │ │ Location: ICSS Shared RAM                                          │ │ │</div>
<div class="line">│ │ │ Size: 32 bits (4 bytes) per descriptor                             │ │ │</div>
<div class="line">│ │ │ ┌────────────────────────────────────────────────────────────────┐ │ │ │</div>
<div class="line">│ │ │ │ Bit 31 | 30    | 29   | 28-18  | 17-16 | Bits 15-0             │ │ │ │</div>
<div class="line">│ │ │ │ Error  | Bcast | VLAN | Length | Port  | Unused/Protocol       │ │ │ │</div>
<div class="line">│ │ │ │ Flag   | Flag  | Tag  | (11b)  | (2b)  | Specific              │ │ │ │</div>
<div class="line">│ │ │ └────────────────────────────────────────────────────────────────┘ │ │ │</div>
<div class="line">│ │ │ • First BD: Contains complete packet length and metadata           │ │ │</div>
<div class="line">│ │ │ • Subsequent BDs: Point to additional 32-byte data blocks          │ │ │</div>
<div class="line">│ │ │ • One BD per 32-byte data block                                    │ │ │</div>
<div class="line">│ │ └────────────────────────────────────────────────────────────────────┘ │ │</div>
<div class="line">│ │                           │                                            │ │</div>
<div class="line">│ │                           │ Points to                                  │ │</div>
<div class="line">│ │                           ▼                                            │ │</div>
<div class="line">│ │ ┌────────────────────────────────────────────────────────────────────┐ │ │</div>
<div class="line">│ │ │ BUFFERS (Packet Data Storage)                                      │ │ │</div>
<div class="line">│ │ │ Location: MSRAM (L3 OCMC RAM)                                      │ │ │</div>
<div class="line">│ │ │ Size: 32 bytes per buffer block                                    │ │ │</div>
<div class="line">│ │ │ ┌────────────────────────────────────────────────────────────────┐ │ │ │</div>
<div class="line">│ │ │ │ Buffer 1 (32B) | Buffer 2 (32B) | Buffer 3 (32B) | Buffer N    │ │ │ │</div>
<div class="line">│ │ │ │ ┌────────────┐ │ ┌────────────┐ │ ┌────────────┐ │ ┌────────┐  │ │ │ │</div>
<div class="line">│ │ │ │ │Eth Header  │ │ │IP Header   │ │ │TCP Header  │ │ │Payload │  │ │ │ │</div>
<div class="line">│ │ │ │ │+ IP start  │ │ │+ TCP start │ │ │+ Payload   │ │ │(remain)│  │ │ │ │</div>
<div class="line">│ │ │ │ │(32 bytes)  │ │ │(32 bytes)  │ │ │(32 bytes)  │ │ │(≤32B)  │  │ │ │ │</div>
<div class="line">│ │ │ │ └────────────┘ │ └────────────┘ │ └────────────┘ │ └────────┘  │ │ │ │</div>
<div class="line">│ │ │ └────────────────────────────────────────────────────────────────┘ │ │ │</div>
<div class="line">│ │ │ • 32-byte aligned blocks                                           │ │ │</div>
<div class="line">│ │ │ • Variable number of blocks per packet (based on packet size)      │ │ │</div>
<div class="line">│ │ │ • Fast access from MSRAM (faster than DDR)                         │ │ │</div>
<div class="line">│ │ └────────────────────────────────────────────────────────────────────┘ │ │</div>
<div class="line">│ └────────────────────────────────────────────────────────────────────────┘ │</div>
<div class="line">└────────────────────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1389"></a>
Collision Queue</h1>
<h2><a class="anchor" id="autotoc_md1390"></a>
What is Queue Contention?</h2>
<p>Queue contention occurs when two PRUs or a PRU and the Host want to acquire the same queue at the same time. This creates a race condition that must be resolved to prevent data corruption and ensure proper packet handling.</p>
<p>There are two main scenarios where contention happens:</p>
<p><b>Host Queue Contention</b>: This occurs when both PRU0 and PRU1 try to write received packets to the same host queue simultaneously. For example, when both ports receive broadcast packets at the same time, both PRUs will attempt to store the packet in the host receive queue.</p>
<p><b>Port Queue Contention</b>: This happens when the Host and a PRU try to access the same port transmit queue. For instance, the host application might want to transmit a packet while the PRU is performing a store-and-forward operation on the same queue.</p>
<h2><a class="anchor" id="autotoc_md1391"></a>
Primary-Secondary Arbitration System</h2>
<p>To resolve these conflicts, ICSS-EMAC uses a Primary-Secondary arbitration scheme where different entities are assigned priority based on the queue type:</p>
<ul>
<li><b>For Host Queues (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga529426b030d582d0589f29b064643cd6">ICSS_EMAC_PORT_0</a>)</b>: PRU0 acts as the primary arbiter and PRU1 acts as the secondary arbiter. This gives PRU0 priority when both PRUs need to access host queues.</li>
<li><b>For Physical Port 0 Transmit Queues (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga8149aef84e214698f4c40e3a6290cab1">ICSS_EMAC_PORT_1</a>)</b>: PRU1 acts as the primary arbiter and the Host acts as the secondary arbiter, since PRU1 manages Physical Port 0 transmit operations.</li>
<li><b>For Physical Port 1 Transmit Queues (<a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga8961b5fbf7d921e0f2869d85386e0df3">ICSS_EMAC_PORT_2</a>)</b>: PRU0 acts as the primary arbiter and the Host acts as the secondary arbiter, since PRU0 manages Physical Port 1 transmit operations.</li>
</ul>
<p>Each queue descriptor contains ownership bits - one for secondary ownership and one for primary ownership. These bits are used to coordinate access between the competing entities.</p>
<h2><a class="anchor" id="autotoc_md1392"></a>
How the Arbitration Works</h2>
<p><b>Primary Arbiter Process</b>: When the primary arbiter wants to acquire a queue, it first checks the secondary ownership bit. If the secondary has already acquired the queue, the primary gives up and stores its packet in a collision queue instead. If the queue is free, the primary sets its ownership bit and proceeds to use the main queue.</p>
<p><b>Secondary Arbiter Process</b>: The secondary arbiter process is more complex because it needs to handle race conditions. First, the secondary checks if the primary ownership bit is set. If so, it goes directly to the collision queue. If the primary bit is clear, the secondary sets its own ownership bit and then immediately re-checks the primary bit. This double-check is crucial because the primary arbiter might have acquired the queue between the secondary's initial check and when it set its own bit. If the primary did acquire the queue during this window, the secondary clears its ownership bit and falls back to using the collision queue.</p>
<h2><a class="anchor" id="autotoc_md1393"></a>
Collision Queue Mechanism</h2>
<p>Collision queues serve as temporary storage when the main queue is busy. Each port has its own collision buffer in MSRAM.</p>
<p>The critical limitation is that each collision queue can only hold a single packet, regardless of the packet size. If a collision queue is already occupied and another contention occurs, the new packet will be dropped.</p>
<h1><a class="anchor" id="autotoc_md1394"></a>
Reception Flow Example</h1>
<p>This section demonstrates how a packet is received from the network and delivered to the host application.</p>
<dl class="section note"><dt>Note</dt><dd>The offsets used here are for demonstration purposes only - the actual offsets when application is running on the target may differ.</dd></dl>
<h2><a class="anchor" id="autotoc_md1395"></a>
Initial State (Empty Queues)</h2>
<div class="fragment"><div class="line">Queue State: Empty</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Queue Descriptor (P0_Q1 - Host Receive Queue)               │</div>
<div class="line">│ ┌─────────────────────────────────────────────────────────┐ │</div>
<div class="line">│ │ Rd_ptr: 0x0400 ← Points to last valid BD (none yet)     │ │</div>
<div class="line">│ │ Wr_ptr: 0x0400 ← Points to first BD to read (none)      │ │</div>
<div class="line">│ │ busy_s: 0      ← Not busy                               │ │</div>
<div class="line">│ └─────────────────────────────────────────────────────────┘ │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Available Buffer Descriptors in ICSS Shared RAM:</div>
<div class="line">┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐</div>
<div class="line">│ BD1  │ │ BD2  │ │ BD3  │ │ BD4  │ ... (unused)</div>
<div class="line">│@0x400│ │@0x404│ │@0x408│ │@0x40C│</div>
<div class="line">└──────┘ └──────┘ └──────┘ └──────┘</div>
<div class="line"> </div>
<div class="line">Available Buffers in MSRAM:</div>
<div class="line">┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐</div>
<div class="line">│Buf1  │ │Buf2  │ │Buf3  │ │Buf4  │ ... (empty)</div>
<div class="line">│ 32B  │ │ 32B  │ │ 32B  │ │ 32B  │</div>
<div class="line">└──────┘ └──────┘ └──────┘ └──────┘</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1396"></a>
Packet Arrives at PRU (Firmware Receives)</h2>
<div class="fragment"><div class="line">Incoming Packet: 68 bytes</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Ethernet Header | IP Header | TCP Header | Payload Data     │</div>
<div class="line">│ (14 bytes)      |(20 bytes) |(20 bytes)  | (14 bytes)       │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line">│◄──────────────── 68 bytes total ────────────────────────────►│</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1397"></a>
Firmware (Producer) Actions</h2>
<p><b>1. Firmware Stores Packet Data in Buffers (MSRAM)</b></p>
<p>PRU Firmware splits 68-byte packet into 32-byte blocks:</p>
<div class="fragment"><div class="line">Buffer 1 (32 bytes):</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Ethernet Header + Partial IP Header                         │</div>
<div class="line">│ (14 + 18 = 32 bytes used)                                   │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Buffer 2 (32 bytes):</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Remaining IP Header + TCP Header + Partial Payload          │</div>
<div class="line">│ (2 + 20 + 10 = 32 bytes used)                               │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Buffer 3 (32 bytes):</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Remaining Payload Data                                      │</div>
<div class="line">│ (4 bytes used, 28 bytes unused in this block)               │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><p><b>2. Firmware Creates Buffer Descriptors (ICSS Shared RAM)</b></p>
<div class="fragment"><div class="line">Buffer Descriptors created by PRU:</div>
<div class="line"> </div>
<div class="line">BD1 @ 0x0400 (First BD - contains packet metadata):</div>
<div class="line">┌───────┬────────┬──────┬──────────┬───────┬──────────┐</div>
<div class="line">│  31   │   30   │  29  │  28-18   │ 17-16 │  15-0    │</div>
<div class="line">├───────┼────────┼──────┼──────────┼───────┼──────────┤</div>
<div class="line">│   0   │   0    │  0   │    68    │   1   │    0     │</div>
<div class="line">│ Error │ B&#39;cast │ VLAN │  Length  │ Port  │ Unused   │</div>
<div class="line">│  No   │   No   │  No  │ 68 bytes │ Port1 │          │</div>
<div class="line">└───────┴────────┴──────┴──────────┴───────┴──────────┘</div>
<div class="line">Points to Buffer 1 in MSRAM</div>
<div class="line"> </div>
<div class="line">BD2 @ 0x0404 (Second BD):</div>
<div class="line">┌───────┬────────┬──────┬──────────┬───────┬──────────┐</div>
<div class="line">│   0   │   0    │  0   │    0     │   0   │    0     │</div>
<div class="line">│ Error │ B&#39;cast │ VLAN │  Length  │ Port  │ Unused   │</div>
<div class="line">│  No   │   No   │  No  │No length │   -   │          │</div>
<div class="line">└───────┴────────┴──────┴──────────┴───────┴──────────┘</div>
<div class="line">Points to Buffer 2 in MSRAM</div>
<div class="line"> </div>
<div class="line">BD3 @ 0x0408 (Third BD):</div>
<div class="line">┌───────┬────────┬──────┬──────────┬───────┬──────────┐</div>
<div class="line">│   0   │   0    │  0   │    0     │   0   │    0     │</div>
<div class="line">│ Error │ B&#39;cast │ VLAN │  Length  │ Port  │ Unused   │</div>
<div class="line">│  No   │   No   │  No  │No length │   -   │          │</div>
<div class="line">└───────┴────────┴──────┴──────────┴───────┴──────────┘</div>
<div class="line">Points to Buffer 3 in MSRAM</div>
</div><!-- fragment --><p><b>3. Firmware Updates Queue Descriptor</b></p>
<p>PRU Firmware updates wr_ptr (producer pointer):</p>
<div class="fragment"><div class="line">Queue Descriptor After PRU Processing:</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Rd_ptr: 0x0400 ← UNCHANGED: Still points to BD1 (first)     │</div>
<div class="line">│ Wr_ptr: 0x040C ← PRU UPDATED: Points past BD3 (last valid)  │</div>
<div class="line">│ busy_s: 0      ← Not busy                                   │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Queue State: Has Data (Wr_ptr &gt; Rd_ptr)</div>
<div class="line">Available for host consumption: 1 packet (68 bytes)</div>
</div><!-- fragment --><p><b>4. Firmware Generates Host Interrupt</b></p>
<p>The PRU firmware triggers interrupt to the host processor via ICSS INTC - notifying that a packet is ready to be received.</p>
<h2><a class="anchor" id="autotoc_md1398"></a>
Host (Consumer) Actions</h2>
<ol type="1">
<li><b>Host Detects New Packet</b>: <code>ICSS_EMAC_rxInterruptHandler</code> wakes up RxTask (<code>ICSS_EMAC_osRxTaskFnc</code>) and <code>ICSS_EMAC_pollPkt()</code> is called.</li>
<li><b>Driver Process</b>: Within <code>ICSS_EMAC_pollPkt()</code>, the function <code>ICSS_EMAC_rxPktInfo2()</code>:<ul>
<li>Gets the Queue Descriptor and checks if read and write pointers differ</li>
<li>Detects a difference and calculates buffer descriptor number</li>
<li>Extracts packet metadata (length, port, etc.) from the first BD</li>
<li>Compares queue number against <code>ethPrioQueue</code> to determine RT/NRT callback</li>
<li>Calls <code><a class="el" href="group__NETWORKING__ICSS__EMAC__MODULE.html#ga6a5967f060e14a11d20eea9cd8b66e5f" title="Retrieves a frame from a host queue and copies it in the allocated stack buffer.">ICSS_EMAC_rxPktGet()</a></code> which copies packet data to application buffer and updates the read pointer</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md1399"></a>
Transmission Flow Example</h1>
<p>This section demonstrates how a packet is transmitted from the host application to the network.</p>
<dl class="section note"><dt>Note</dt><dd>The offsets used here are for demonstration purposes only - the actual offsets when application is running on the target may differ.</dd></dl>
<h2><a class="anchor" id="autotoc_md1400"></a>
Initial State (Empty Transmit Queue)</h2>
<div class="fragment"><div class="line">Port 1 Transmit Queue (P1_Q1) - Initial State:</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Queue Descriptor (P1_Q1 - Port 1 Transmit Queue)            │</div>
<div class="line">│ ┌─────────────────────────────────────────────────────────┐ │</div>
<div class="line">│ │ Rd_ptr: 0x1020 ← Points to next BD for driver to read   │ │</div>
<div class="line">│ │ Wr_ptr: 0x1020 ← Points to next BD for firmware write   │ │</div>
<div class="line">│ │ busy_s: 0      ← Not busy                               │ │</div>
<div class="line">│ │ status: empty  ← Queue is empty (Rd_ptr == Wr_ptr)      │ │</div>
<div class="line">│ └─────────────────────────────────────────────────────────┘ │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Available Buffer Descriptors in ICSS Shared RAM:</div>
<div class="line">┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐</div>
<div class="line">│ BD1  │ │ BD2  │ │ BD3  │ │ BD4  │ ... (unused)</div>
<div class="line">│@1020 │ │@1024 │ │@1028 │ │@102C │</div>
<div class="line">└──────┘ └──────┘ └──────┘ └──────┘</div>
<div class="line"> </div>
<div class="line">Available Buffers in MSRAM:</div>
<div class="line">┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐</div>
<div class="line">│Buf1  │ │Buf2  │ │Buf3  │ │Buf4  │ ... (empty)</div>
<div class="line">│ 32B  │ │ 32B  │ │ 32B  │ │ 32B  │</div>
<div class="line">└──────┘ └──────┘ └──────┘ └──────┘</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1401"></a>
Application Calls ICSS_EMAC_txPacket</h2>
<div class="fragment"><div class="line">Application Request:</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ ICSS_EMAC_TxArgument txArgs:                                │</div>
<div class="line">│ ├─ icssEmacHandle: handle                                   │</div>
<div class="line">│ ├─ srcAddress: &amp;applicationBuffer[0]                        │</div>
<div class="line">│ ├─ portNumber: ICSS_EMAC_PORT_1                             │</div>
<div class="line">│ ├─ queuePriority: ICSS_EMAC_QUEUE1                          │</div>
<div class="line">│ └─ lengthOfPacket: 100 bytes                                │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Application Buffer (100 bytes):</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Ethernet Header | IP Header | TCP Header | Payload Data     │</div>
<div class="line">│ (14 bytes)      |(20 bytes) |(20 bytes)  | (46 bytes)       │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line">│◄──────────────── 100 bytes total ───────────────────────────►│</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1402"></a>
Driver (Producer) Actions in ICSS_EMAC_txPacketEnqueue</h2>
<ol type="1">
<li><b>Queue Validation and Selection</b>: The driver validates port number, queue priority, packet length, and link status, then selects the appropriate transmit queue.</li>
</ol>
<p><b>2. Queue Contention Check (Switch Mode)</b></p>
<div class="fragment"><div class="line">Driver checks queue availability:</div>
<div class="line"> </div>
<div class="line">Queue Descriptor Check:</div>
<div class="line">┌────────────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Read queue descriptor busy_m bit (Primary Arbiter busy bit)        │</div>
<div class="line">│ If busy_m == 0: Queue available                                    │</div>
<div class="line">│ If busy_m == 1: Queue busy, use collision queue                    │</div>
<div class="line">└────────────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Assume queue is available, so driver acquires it:</div>
<div class="line">1. Set busy_s bit (Secondary Arbiter busy) to acquire queue</div>
<div class="line">2. Re-check busy_m bit to ensure successful acquisition</div>
<div class="line">3. If acquisition failed, fall back to collision queue</div>
</div><!-- fragment --><p><b>3. Driver Sets Busy Flag and Calculates Space</b></p>
<div class="fragment"><div class="line">Queue Descriptor After Driver Acquisition:</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Rd_ptr: 0x1020 ← Unchanged (firmware will read from here)   │</div>
<div class="line">│ Wr_ptr: 0x1020 ← Current write position                     │</div>
<div class="line">│ busy_s: 1      ← DRIVER SET: Acquiring queue                │</div>
<div class="line">│ status: busy   ← Driver is writing                          │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Space Calculation:</div>
<div class="line">- Packet size: 100 bytes</div>
<div class="line">- Blocks needed: ⌈100/32⌉ = 4 blocks (32+32+32+4 bytes)</div>
<div class="line">- Buffer descriptors needed: 4 BDs</div>
<div class="line">- New Wr_ptr will be: 0x1020 + (4 × 4) = 0x1030</div>
</div><!-- fragment --><p><b>4. Driver Creates Buffer Descriptors</b></p>
<div class="fragment"><div class="line">Buffer Descriptors created by Driver:</div>
<div class="line"> </div>
<div class="line">BD1 @ 0x1020 (First BD - contains packet metadata):</div>
<div class="line">┌─────┬─────┬─────┬─────────┬─────┬─────────────────────────┐</div>
<div class="line">│ 31  │ 30  │ 29  │  28-18  │17-16│         15-0            │</div>
<div class="line">├─────┼─────┼─────┼─────────┼─────┼─────────────────────────┤</div>
<div class="line">│  0  │  0  │  0  │   100   │  1  │           0             │</div>
<div class="line">│Error│Bcast│VLAN │ Length  │Port │        Unused           │</div>
<div class="line">│ No  │ No  │ No  │100 bytes│Port1│                         │</div>
<div class="line">└─────┴─────┴─────┴─────────┴─────┴─────────────────────────┘</div>
<div class="line">Points to Buffer 1 in MSRAM</div>
<div class="line"> </div>
<div class="line">BD2 @ 0x1024, BD3 @ 0x1028, BD4 @ 0x102C:</div>
<div class="line">┌─────┬─────┬─────┬─────────┬─────┬─────────────────────────┐</div>
<div class="line">│  0  │  0  │  0  │    0    │  0  │           0             │</div>
<div class="line">│Error│Bcast│VLAN │ Length  │Port │        Unused           │</div>
<div class="line">│ No  │ No  │ No  │No length│  -  │                         │</div>
<div class="line">└─────┴─────┴─────┴─────────┴─────┴─────────────────────────┘</div>
<div class="line">Point to Buffers 2, 3, 4 respectively</div>
</div><!-- fragment --><p><b>5. Driver Copies Data to Buffers (MSRAM)</b></p>
<p>Driver copies the 100-byte packet from the application buffer to the MSRAM. The logical partitioning of the 100-byte packet in terms of buffers of 32 bytes would look like this:</p>
<div class="fragment"><div class="line">Buffer 1 (32 bytes) @ MSRAM offset:</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Ethernet Header + Partial IP Header                         │</div>
<div class="line">│ (14 + 18 = 32 bytes used)                                   │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Buffer 2 (32 bytes):</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Remaining IP Header + TCP Header + Partial Payload          │</div>
<div class="line">│ (2 + 20 + 10 = 32 bytes used)                               │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Buffer 3 (32 bytes):</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Payload Data (continuing)                                   │</div>
<div class="line">│ (32 bytes used)                                             │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Buffer 4 (32 bytes):</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Remaining Payload Data                                      │</div>
<div class="line">│ (4 bytes used, 28 bytes unused)                             │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --><p><b>6. Driver Updates Queue Descriptor</b></p>
<div class="fragment"><div class="line">Queue Descriptor After Driver Data Copy:</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Rd_ptr: 0x1020 ← Unchanged (firmware reads from here)       │</div>
<div class="line">│ Wr_ptr: 0x1030 ← DRIVER UPDATED: Points to next free BD     │</div>
<div class="line">│ busy_s: 0      ← DRIVER CLEARED: Copy complete              │</div>
<div class="line">│ status: ready  ← Packet ready for firmware transmission     │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Queue State: Has Data (Wr_ptr &gt; Rd_ptr)</div>
<div class="line">Available for firmware transmission: 1 packet (100 bytes)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1403"></a>
Firmware (Consumer) Actions</h2>
<p><b>1. Firmware Detects New Packet</b></p>
<div class="fragment"><div class="line">PRU Firmware (Transmit Task):</div>
<div class="line">1. Micro-scheduler calls TX Task in round-robin manner</div>
<div class="line">2. TX Task scans transmit queues (highest priority first)</div>
<div class="line">3. Finds P1_Q1 has data: Wr_ptr (0x1030) &gt; Rd_ptr (0x1020)</div>
<div class="line">4. Reads BD1 to get packet info: Length=100, Port=1</div>
<div class="line">5. Sets XMT_active flag to indicate transmission in progress</div>
</div><!-- fragment --><p><b>2. Firmware Transmission Process</b></p>
<div class="fragment"><div class="line">PRU Transmit Task Phases:</div>
<div class="line"> </div>
<div class="line">XMT_FB (Transmit First Block):</div>
<div class="line">├─ Initialize TX context from BD1</div>
<div class="line">├─ Fetch first 32 bytes from Buffer 1</div>
<div class="line">└─ Push first 32 bytes to TX FIFO</div>
<div class="line"> </div>
<div class="line">XMT_NB (Transmit Next Block):</div>
<div class="line">├─ Monitor TX FIFO fill level</div>
<div class="line">├─ Fetch next 32-byte blocks (Buffers 2, 3)</div>
<div class="line">├─ Push data to TX FIFO as space becomes available</div>
<div class="line">└─ Continue until last block</div>
<div class="line"> </div>
<div class="line">XMT_LB (Transmit Last Block):</div>
<div class="line">├─ Push remaining bytes from Buffer 4 (4 bytes)</div>
<div class="line">├─ Append CRC to frame</div>
<div class="line">├─ Wait for transmission completion (TX_EOF event)</div>
<div class="line">└─ Update queue descriptor</div>
</div><!-- fragment --><p><b>3. Firmware Updates Queue Descriptor</b></p>
<div class="fragment"><div class="line">Queue Descriptor After Firmware Transmission:</div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Rd_ptr: 0x1030 ← FIRMWARE UPDATED: Advanced past packet     │</div>
<div class="line">│ Wr_ptr: 0x1030 ← Unchanged                                  │</div>
<div class="line">│ busy_s: 0      ← Not busy                                   │</div>
<div class="line">│ status: empty  ← Queue is empty again (Rd_ptr == Wr_ptr)    │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Queue State: Empty again</div>
<div class="line">Buffers 1, 2, 3, 4 are now available for reuse</div>
<div class="line">Buffer Descriptors BD1, BD2, BD3, BD4 are available for reuse</div>
</div><!-- fragment --><p><b>4. Packet Transmitted on Ethernet</b></p>
<div class="fragment"><div class="line">PRU Output:</div>
<div class="line">┌────────────────────────────────────────────────────────────────┐</div>
<div class="line">│ Original 100-byte packet + 4-byte CRC = 104 bytes on wire      │</div>
<div class="line">│ ┌────────────────────────────────────────────────────────────┐ │</div>
<div class="line">│ │ Ethernet Header | IP | TCP | Payload    | CRC (auto-added) │ │</div>
<div class="line">│ │ (14 bytes)      |20B |20B  | (46 bytes) | (4 bytes)        │ │</div>
<div class="line">│ └────────────────────────────────────────────────────────────┘ │</div>
<div class="line">└────────────────────────────────────────────────────────────────┘</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
