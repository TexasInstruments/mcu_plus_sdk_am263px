%%{
    let module = system.modules['/drivers/gpmc/gpmc'];
    let gpmcEdmaInstances = [];
    for(let i=0; i < module.$instances.length; i++) {
        let instance = module.$instances[i];
        if(instance.dmaEnable == true) {
            gpmcEdmaInstances.push(module.getInstanceConfig(instance).edmaDriver);
        }
    }
%%}

% let dmaRestrictRegions = module.getDmaRestrictedRegions();
/*
 * GPMC
 */

/* GPMC attributes */
static GPMC_HwAttrs gGpmcAttrs[CONFIG_GPMC_NUM_INSTANCES] =
{
% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % let config = module.getInstanceConfig(instance);
    % let deviceConfig = module.getGpmcDeviceConfig(instance);
    % let name = config.name;
    {
        .gpmcBaseAddr         = `config.baseAddr`,
        .dataBaseAddr         = `config.dataBaseAddr`,
        .inputClkFreq         = `config.inputClkFreq`U,
        .intrNum              = `config.intrNum`,
        .intrPriority         = `config.intrPriority`U,
        .chipSelBaseAddr      = `config.chipSelBaseAddr`U,
        .chipSelAddrSize      = GPMC_CS_MASK_ADDR_SIZE_`config.chipSelAddrSize`,
        % if(config.clockRateDiv == 1) {
        .clkDivider           = CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_DIVBY1,
        % } else if (config.clockRateDiv == 2) {
        .clkDivider           = CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_DIVBY2,
        % } else if (config.clockRateDiv == 3) {
        .clkDivider           = CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_DIVBY3,
        % } else {
        .clkDivider           = CSL_GPMC_CONFIG1_GPMCFCLKDIVIDER_DIVBY4,
        % }
        % if(config.waitPinselect == "WAIT0 PIN") {
        .waitPinNum           = CSL_GPMC_CONFIG1_WAITPINSELECT_W0,
        % } else {
        .waitPinNum           = CSL_GPMC_CONFIG1_WAITPINSELECT_W1,
        % }
        .addrDataMux          = `config.addrDataMux`,
        .timeLatency          = `config.timeLatency`,
        .waitPinPol           = `deviceConfig.waitPinPol`,
        .timingParams         =
        {
            .csOnTime               =   `config.csOnTime`,
            .csRdOffTime            =   `config.csRdOffTime`,
            .csWrOffTime            =   `config.csWrOffTime`,
            .advOnTime              =   `config.advOnTime`,
            .advRdOffTime           =   `config.advRdOffTime`,
            .advWrOffTime           =   `config.advWrOffTime`,
            .advAadMuxOnTime        =   `config.advAadMuxOnTime`,
            .advAadMuxRdOffTime     =   `config.advAadMuxRdOffTime`,
            .advAadMuxWrOffTime     =   `config.advAadMuxWrOffTime`,
            .weOnTtime              =   `config.weOnTtime`,
            .weOffTime              =   `config.weOffTime`,
            .oeOnTime               =   `config.oeOnTime`,
            .oeOffTime              =   `config.oeOffTime`,
            .oeAadMuxOnTime         =   `config.oeAadMuxOnTime`,
            .oeAadMuxOffTime        =   `config.oeAadMuxOffTime`,
            .pageBurstAccess        =   `config.pageBurstAccess`,
            .rdAccessTime           =   `config.rdAccessTime`,
            .wrAcessTime            =   `config.wrAcessTime`,
            .rdCycleTime            =   `config.rdCycleTime`,
            .wrCycleTime            =   `config.wrCycleTime`,
            .wrDataOnMuxBusTime     =   `config.wrDataOnMuxBusTime`,
            .cycle2CycleDelay       =   `config.cycle2CycleDelay`,
            .cycleDelaySameChipSel  =   `config.cycleDelaySameChipSel`,
            .cycleDelayDiffChipSel  =   `config.cycleDelayDiffChipSel`,
            .busTurnAroundTime      =   `config.busTurnAroundTime`,
        },
        .readType               =   `config.readType`,
        .csExDelay              =   `config.csExDelay`,
        .accessType             =   `config.accessType`,
    },
% }
};
/* GPMC objects - initialized by the driver */
static GPMC_Object gGpmcObjects[CONFIG_GPMC_NUM_INSTANCES];
/* GPMC driver configuration */
GPMC_Config gGpmcConfig[CONFIG_GPMC_NUM_INSTANCES] =
{
% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    {
        &gGpmcAttrs[`instance.$name.toUpperCase()`],
        &gGpmcObjects[`instance.$name.toUpperCase()`],
    },
% }
};

uint32_t gGpmcConfigNum = CONFIG_GPMC_NUM_INSTANCES;

% let instance = module.$instances[0];
% let config = module.getInstanceConfig(instance);

#include <drivers/gpmc/v0/dma/gpmc_dma.h>
#include <drivers/gpmc/v0/dma/edma/gpmc_dma_edma.h>
#include <drivers/edma.h>

Gpmc_DmaArgs gGpmcEdmaArgs[`module.$instances.length`];
GPMC_DmaConfig gGpmcDmaConfig[CONFIG_GPMC_NUM_DMA_INSTANCES] =
{
%for(let i = 0; i < gpmcEdmaInstances.length; i++) {
    {
        .gpmcDmaArgs = &gGpmcEdmaArgs[`i`],
    }
%}
};

uint32_t gGpmcDmaConfigNum = CONFIG_GPMC_NUM_DMA_INSTANCES;

