%%{
    let module = system.modules["/networking/enet_cpsw/enet_cpsw"];
%%}
% let instance = module.$instances[0];

%%{
function getTxNumPkts(module, instance) {
    let txPktAry = new Array();

    for (var i = 0; i < module.getTxChannelCount(instance); i++)
    {
        txPktAry.push((module.getChannelConfig(instance, "TX", i)).PacketsCount);
    }
    return txPktAry;
}

function getRxNumPkts(module, instance) {
    let rxPktAry = new Array();

    for (var i = 0; i < module.getRxChannelCount(instance); i++)
    {
        rxPktAry.push((module.getChannelConfig(instance, "RX", i)).PacketsCount);
    }
    return rxPktAry;
}

function getRxAllocMacInfo(module, instance) {
    let rxPktAry = new Array();

    for (var i = 0; i < module.getRxChannelCount(instance); i++)
    {
        rxPktAry.push((module.getChannelConfig(instance, "RX", i)).macAddrCount);
    }
    return rxPktAry;
}

function getTxDmaGlobalEvtCfg(module, instance) {
    let txDmaCfgAry = new Array();

    for (var i = 0; i < module.getTxChannelCount(instance); i++)
    {
        txDmaCfgAry.push((module.getChannelConfig(instance, "TX", i)).useGlobalEvt);
    }
    return txDmaCfgAry;
}

function getRxDmaGlobalEvtCfg(module, instance) {
    let rxDmaCfgAry = new Array();

    for (var i = 0; i < module.getRxChannelCount(instance); i++)
    {
        rxDmaCfgAry.push((module.getChannelConfig(instance, "RX", i)).useGlobalEvt);
    }
    return rxDmaCfgAry;
}

function getRxDmaSizeThreshEn(module, instance) {
    let rxDmaCfgAry = new Array();

    for (var i = 0; i < module.getRxChannelCount(instance); i++)
    {
        rxDmaCfgAry.push((module.getChannelConfig(instance, "RX", i)).sizeThreshEn);
    }
    return rxDmaCfgAry;
}

function getRxDmaIsDefaultFlow(module, instance) {
    let rxDmaCfgAry = new Array();

    for (var i = 0; i < module.getRxChannelCount(instance); i++)
    {
        rxDmaCfgAry.push((module.getChannelConfig(instance, "RX", i)).useDefaultFlow);
    }
    return rxDmaCfgAry;
}

function getDmaCfgInitArray(module, instance, indent) {
    let rxDmaCfgAry = new Array();

    for (var i = 0; i < module.getRxChannelCount(instance); i++)
    {
        let rxChCfg = module.getChannelConfig(instance, "RX", i);
        let rxChCfgInitStr = "\n\t[" + i + "] = " +
                             "\n\t{"              +
                                "\n\t\t.maxNumRxPkts    = " + rxChCfg.PacketsCount + "," +
                                "\n\t\t.numValidMacAddress = " + rxChCfg.macAddrCount + "," +
                                "\n\t\t.useGlobalEvt    = " + rxChCfg.useGlobalEvt + "," +
                                "\n\t\t.useDefaultFlow  = " + rxChCfg.useDefaultFlow + "," +
                                "\n\t\t.sizeThreshEn    = " + rxChCfg.sizeThreshEn + "," +
                             "\n\t}";
        const numSpaces = 4 + indent;
        let rxChCfgInitStrFormat = rxChCfgInitStr.replace(/\t/g, ' '.repeat(numSpaces));
        rxDmaCfgAry.push(rxChCfgInitStrFormat);
    }
    return rxDmaCfgAry;
}


%%}

static void EnetAppUtils_absFlowIdx2FlowIdxOffset(Enet_Handle hEnet,
                                                  uint32_t coreId,
                                                  uint32_t absRxFlowId,
                                                  uint32_t *pStartFlowIdx,
                                                  uint32_t *pFlowIdxOffset)
{
    uint32_t p0FlowIdOffset;

    p0FlowIdOffset = EnetAppUtils_getStartFlowIdx(hEnet, coreId);
    EnetAppUtils_assert(absRxFlowId >= p0FlowIdOffset);
    *pStartFlowIdx  = p0FlowIdOffset;
    *pFlowIdxOffset = (absRxFlowId - p0FlowIdOffset);
}

static void EnetAppUtils_openRxFlowForChIdx(Enet_Type enetType,
                                            Enet_Handle hEnet,
                                            uint32_t coreKey,
                                            uint32_t coreId,
                                            bool useDefaultFlow,
                                            uint32_t allocMacAddrCnt,
                                            uint32_t chIdx,
                                            uint32_t *pRxFlowStartIdx,
                                            uint32_t *pRxFlowIdx,
                                            uint8_t macAddr[ENET_MAX_NUM_MAC_PER_PHER][ENET_MAC_ADDR_LEN],
                                            EnetDma_RxChHandle *pRxFlowHandle,
                                            EnetUdma_OpenRxFlowPrms *pRxFlowPrms)
{
    EnetDma_Handle hDma = Enet_getDmaHandle(hEnet);
    int32_t status = ENET_SOK;

    EnetAppUtils_assert(hDma != NULL);

    status = EnetAppUtils_allocRxFlowForChIdx(hEnet,
                                              coreKey,
                                              coreId,
                                              chIdx,
                                              pRxFlowStartIdx,
                                              pRxFlowIdx);
    EnetAppUtils_assert(status == ENET_SOK);

    pRxFlowPrms->startIdx = *pRxFlowStartIdx;
    pRxFlowPrms->flowIdx  = *pRxFlowIdx;
    pRxFlowPrms->chIdx    = chIdx;

    *pRxFlowHandle = EnetUdma_openRxFlow(hDma, pRxFlowPrms);
    EnetAppUtils_assert(*pRxFlowHandle != NULL);

    if (useDefaultFlow)
    {
        if (chIdx == 0U)
        {
           for (uint32_t i = 0; i < allocMacAddrCnt; i++)
           {
                status = EnetAppUtils_allocMac(hEnet, coreKey, coreId, macAddr[i]);
                EnetAppUtils_assert(status == ENET_SOK);

                if (Enet_isCpswFamily(enetType))
                {
                    EnetAppUtils_addHostPortEntry(hEnet, coreId, macAddr[i]);
                }
                else
                {
                   // Should we add this entry to ICSSG FDB?
                }
            }
        }

        status = EnetAppUtils_regDfltRxFlowForChIdx(hEnet,
                                                    coreKey,
                                                    coreId,
                                                    chIdx,
                                                    *pRxFlowStartIdx,
                                                    *pRxFlowIdx);
    }
    else
    {
        for (uint32_t i = 0; i < allocMacAddrCnt; i++)
        {
            if (Enet_isCpswFamily(enetType))
            {
                EnetAppUtils_assert(chIdx == 0U);

                status = EnetAppUtils_allocMac(hEnet, coreKey, coreId, macAddr[i]);
                EnetAppUtils_assert(status == ENET_SOK);
                if (i == 0)
                {
                    status = EnetAppUtils_regDstMacRxFlow(hEnet,
                                                          coreKey,
                                                          coreId,
                                                          *pRxFlowStartIdx,
                                                          *pRxFlowIdx,
                                                          macAddr[i]);
                }
            }
        }
    }

    EnetAppUtils_assert(status == ENET_SOK);
}

static void EnetAppUtils_closeRxFlowForChIdx(Enet_Type enetType,
                                            Enet_Handle hEnet,
                                            uint32_t coreKey,
                                            uint32_t coreId,
                                            bool useDefaultFlow,
                                            EnetDma_PktQ *pFqPktInfoQ,
                                            EnetDma_PktQ *pCqPktInfoQ,
                                            uint32_t chIdx,
                                            uint32_t rxFlowStartIdx,
                                            uint32_t rxFlowIdx,
                                            uint32_t allocMacAddrCnt,
                                            uint8_t macAddr[ENET_MAX_NUM_MAC_PER_PHER][ENET_MAC_ADDR_LEN],
                                            EnetDma_RxChHandle hRxFlow)
{
    int32_t status = ENET_SOK;

    EnetQueue_initQ(pFqPktInfoQ);
    EnetQueue_initQ(pCqPktInfoQ);

    EnetDma_disableRxEvent(hRxFlow);

    if (useDefaultFlow)
    {
        status = EnetAppUtils_unregDfltRxFlowForChIdx(hEnet,
                                                      coreKey,
                                                      coreId,
                                                      chIdx,
                                                      rxFlowStartIdx,
                                                      rxFlowIdx);
        EnetAppUtils_assert(status == ENET_SOK);

        for (uint32_t i = 0; i < allocMacAddrCnt; i++)
        {
            status = EnetAppUtils_freeMac(hEnet,
                                          coreKey,
                                          coreId,
                                          macAddr[i]);
            EnetAppUtils_assert(status == ENET_SOK);

            if (Enet_isCpswFamily(enetType))
            {
                EnetAppUtils_delAddrEntry(hEnet, coreId, macAddr[i]);
            }
        }
    }
    else
    {
        if (Enet_isCpswFamily(enetType))
        {
            EnetAppUtils_assert(allocMacAddrCnt > 0);

            for (uint32_t i = 0; i < allocMacAddrCnt; i++)
            {
                if (i == 0)
                {
                    status = EnetAppUtils_unregDstMacRxFlow(hEnet,
                                                    coreKey,
                                                    coreId,
                                                    rxFlowStartIdx,
                                                    rxFlowIdx,
                                                    macAddr[i]);
                    EnetAppUtils_assert(status == ENET_SOK);
                }
                EnetAppUtils_delAddrEntry(hEnet, coreId, macAddr[i]);

                status = EnetAppUtils_freeMac(hEnet,
                                          coreKey,
                                          coreId,
                                          macAddr[i]);
                EnetAppUtils_assert(status == ENET_SOK);
            }
        }
    }

    status = EnetUdma_closeRxFlow(hRxFlow, pFqPktInfoQ, pCqPktInfoQ);
    EnetAppUtils_assert(status == ENET_SOK);


    status = EnetAppUtils_freeRxFlowForChIdx(hEnet,
                                             coreKey,
                                             coreId,
                                             chIdx,
                                             rxFlowIdx);
    EnetAppUtils_assert(status == ENET_SOK);
}

void EnetApp_closeTxDma(uint32_t enetTxDmaChId,
                        Enet_Handle hEnet,
                        uint32_t coreKey,
                        uint32_t coreId,
                        EnetDma_PktQ *fqPktInfoQ,
                        EnetDma_PktQ *cqPktInfoQ)
{
    EnetAppTxDmaSysCfg_Obj *tx;

    EnetAppUtils_assert(enetTxDmaChId < ENET_ARRAYSIZE(gEnetAppSysCfgObj.dma.tx));
    tx = &gEnetAppSysCfgObj.dma.tx[enetTxDmaChId];
    EnetQueue_initQ(fqPktInfoQ);
    EnetQueue_initQ(cqPktInfoQ);
    EnetApp_retrieveFreeTxPkts(tx->hTxCh, cqPktInfoQ);
    EnetAppUtils_closeTxCh(hEnet,
                           coreKey,
                           coreId,
                           fqPktInfoQ,
                           cqPktInfoQ,
                           tx->hTxCh,
                           tx->txChNum);
    memset(tx, 0, sizeof(*tx));
}

void EnetApp_closeRxDma(uint32_t enetRxDmaChId,
                        Enet_Handle hEnet,
                        uint32_t coreKey,
                        uint32_t coreId,
                        EnetDma_PktQ *fqPktInfoQ,
                        EnetDma_PktQ *cqPktInfoQ)
{
    EnetAppRxDmaSysCfg_Obj *rx;
    Enet_Type enetType;
    uint32_t instId;
    const  uint32_t chIdx = ENET_CPSW_RX_CH_ID;
    int32_t status;
    const EnetApp_GetRxDmaHandleOutArgs rxDmaInfo[ENET_SYSCFG_RX_FLOWS_NUM] =
    {
        `getDmaCfgInitArray(module, instance, 4)`

    };

    status = Enet_getHandleInfo(hEnet,
                                &enetType,
                                &instId);
    EnetAppUtils_assert(status == ENET_SOK);
    (void)instId; /* Instd id not used */

    EnetAppUtils_assert(enetRxDmaChId < ENET_ARRAYSIZE(gEnetAppSysCfgObj.dma.rx));
    rx = &gEnetAppSysCfgObj.dma.rx[enetRxDmaChId];
    /* Close RX channel */
    EnetQueue_initQ(fqPktInfoQ);
    EnetQueue_initQ(cqPktInfoQ);

    EnetAppUtils_assert(enetRxDmaChId < ENET_ARRAYSIZE(rxDmaInfo));
    EnetAppUtils_closeRxFlowForChIdx(enetType,
                                     hEnet,
                                     coreKey,
                                     coreId,
                                     rxDmaInfo[enetRxDmaChId].useDefaultFlow,
                                     fqPktInfoQ,
                                     cqPktInfoQ,
                                     chIdx,
                                     rx->rxFlowStartIdx,
                                     rx->rxFlowIdx,
                                     rx->numValidMacAddress,
                                     rx->macAddr,
                                     rx->hRxCh);

    EnetAppSoc_releaseMacAddrList(rx->macAddr, rx->numValidMacAddress);
    memset(rx, 0, sizeof(*rx));
}

void EnetApp_getTxDmaHandle(uint32_t enetTxDmaChId,
                            const EnetApp_GetDmaHandleInArgs *inArgs,
                            EnetApp_GetTxDmaHandleOutArgs *outArgs)
{
    int32_t status;
    EnetAppTxDmaSysCfg_Obj *tx;
    const uint32_t txNumPkts[ENET_SYSCFG_TX_CHANNELS_NUM] =
                           {
                            `getTxNumPkts(module, instance)`
                           };
    const uint32_t useGlobalEvt[ENET_SYSCFG_TX_CHANNELS_NUM] =
                           {
                             `getTxDmaGlobalEvtCfg(module, instance)`
                           };

    EnetAppUtils_assert(enetTxDmaChId < ENET_ARRAYSIZE(gEnetAppSysCfgObj.dma.tx));
    tx = &gEnetAppSysCfgObj.dma.tx[enetTxDmaChId];

    EnetAppUtils_assert(tx->hTxCh != NULL);
    status = EnetDma_registerTxEventCb(tx->hTxCh, inArgs->notifyCb, inArgs->cbArg);
    EnetAppUtils_assert(status == ENET_SOK);

    outArgs->hTxCh = tx->hTxCh;
    outArgs->txChNum = tx->txChNum;
    EnetAppUtils_assert(enetTxDmaChId < ENET_ARRAYSIZE(txNumPkts));
    outArgs->maxNumTxPkts = txNumPkts[enetTxDmaChId];
    outArgs->useGlobalEvt = useGlobalEvt[enetTxDmaChId];
    return;
}

void EnetApp_getMacAddress(uint32_t enetRxDmaChId,
                            EnetApp_GetMacAddrOutArgs *outArgs)
{

    EnetAppUtils_assert(enetRxDmaChId < ENET_ARRAYSIZE(gEnetAppSysCfgObj.dma.rx));
    EnetAppRxDmaSysCfg_Obj* rx = &gEnetAppSysCfgObj.dma.rx[enetRxDmaChId];

    outArgs->macAddressCnt = rx->numValidMacAddress;
    EnetAppUtils_assert(outArgs->macAddressCnt <= ENET_MAX_NUM_MAC_PER_PHER);
    for (uint32_t i = 0; i < outArgs->macAddressCnt; i++)
    {
        EnetUtils_copyMacAddr(outArgs->macAddr[i], rx->macAddr[i]);
    }

}

void EnetApp_getRxDmaHandle(uint32_t enetRxDmaChId,
                            const EnetApp_GetDmaHandleInArgs *inArgs,
                            EnetApp_GetRxDmaHandleOutArgs *outArgs)
{
    int32_t status;
    EnetAppRxDmaSysCfg_Obj *rx;
    const EnetApp_GetRxDmaHandleOutArgs rxDmaInfo[ENET_SYSCFG_RX_FLOWS_NUM] =
    {
        `getDmaCfgInitArray(module, instance, 4)`

    };

    EnetAppUtils_assert(enetRxDmaChId < ENET_ARRAYSIZE(gEnetAppSysCfgObj.dma.rx));
    rx = &gEnetAppSysCfgObj.dma.rx[enetRxDmaChId];

    EnetAppUtils_assert(rx->hRxCh != NULL);
    status = EnetDma_registerRxEventCb(rx->hRxCh, inArgs->notifyCb, inArgs->cbArg);
    EnetAppUtils_assert(status == ENET_SOK);

    outArgs->hRxCh = rx->hRxCh;
    outArgs->rxFlowIdx = rx->rxFlowIdx;
    outArgs->rxFlowStartIdx = rx->rxFlowStartIdx;
    EnetAppUtils_assert(enetRxDmaChId < ENET_ARRAYSIZE(rxDmaInfo));
    outArgs->numValidMacAddress = rxDmaInfo[enetRxDmaChId].numValidMacAddress;
    for (uint32_t i = 0; i < rxDmaInfo[enetRxDmaChId].numValidMacAddress; i++)
    {
        EnetUtils_copyMacAddr(outArgs->macAddr[i], rx->macAddr[i]);
    }
    outArgs->maxNumRxPkts = rxDmaInfo[enetRxDmaChId].maxNumRxPkts;
    outArgs->sizeThreshEn = rxDmaInfo[enetRxDmaChId].sizeThreshEn;
    outArgs->useDefaultFlow = rxDmaInfo[enetRxDmaChId].useDefaultFlow;
    outArgs->useGlobalEvt   = rxDmaInfo[enetRxDmaChId].useGlobalEvt;
    return;
}

#define ENET_SYSCFG_DEFAULT_NUM_TX_PKT                                     (`module.getDefaultPacketCount("TX")`U)
#define ENET_SYSCFG_DEFAULT_NUM_RX_PKT                                     (`module.getDefaultPacketCount("RX")`U)

void EnetAppUtils_setCommonRxFlowPrms(EnetUdma_OpenRxFlowPrms *pRxFlowPrms)
{
    pRxFlowPrms->numRxPkts           = ENET_SYSCFG_DEFAULT_NUM_RX_PKT;
    pRxFlowPrms->disableCacheOpsFlag = false;
    pRxFlowPrms->rxFlowMtu           = ENET_MEM_LARGE_POOL_PKT_SIZE;
}

void EnetAppUtils_setCommonTxChPrms(EnetUdma_OpenTxChPrms *pTxChPrms)
{
    pTxChPrms->numTxPkts           = ENET_SYSCFG_DEFAULT_NUM_TX_PKT;
    pTxChPrms->disableCacheOpsFlag = false;
}


Udma_DrvHandle EnetApp_getUdmaInstanceHandle(void)
{
    Udma_DrvHandle hUdmaDrv;

    hUdmaDrv = &gUdmaDrvObj[CONFIG_UDMA_PKTDMA_0];
    return hUdmaDrv;
}

