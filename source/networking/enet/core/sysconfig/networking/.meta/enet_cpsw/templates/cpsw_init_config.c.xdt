%%{
    let module = system.modules["/networking/enet_cpsw/enet_cpsw"];
%%}
% let instance = module.$instances[0];
% let common = system.getScript("/common");
% let device = common.getDeviceName();
% let soc = common.getSocName();
% let enetutilsScript = system.getScript("./../../common/enet_cpsw_utils");

%%{
function getAleModeFlags(module, instance) {
    let aleModeFlag = "(";

    aleModeFlag += "CPSW_ALE_CFG_MODULE_EN";

    aleModeFlag += (instance.BypassEnable === true) ? " | CPSW_ALE_CFG_BYPASS_EN" : "";
    aleModeFlag += (instance.UnknownUnicastFloodToHost === true) ? " | CPSW_ALE_CFG_UNKNOWN_UCAST_FLOOD2HOST" : "";

    aleModeFlag += ")";
    return aleModeFlag;
}

function getAlePortMask(instance, property) {
    let alePortMask = "(";
    let portAry = new Array();
    let hostPort = instance[property + "HostPortEn"];
    let macPort1 = instance[property + "MacPort1En"];
    let macPortRest = new Array();
    const maxMacPorts = 8;

    alePortMask += "0";

    for (var i = 2; i <= maxMacPorts; i++)
    {
        if (instance.hasOwnProperty(property + "MacPort" + i.toString() + "En"))
        {
            macPortRest.push(instance[property + "MacPort" + i.toString() + "En"]);
        }
    }
    portAry.push(hostPort);
    portAry.push(macPort1);
    for (var macPort of macPortRest) {
        portAry.push(macPort);
    }

    for (var i in portAry) {
        if (portAry[i] === true)
        {
            if (i.toString() === "0")
            {
                alePortMask += " | CPSW_ALE_HOST_PORT_MASK";
            }
            else
            {
                alePortMask += " | CPSW_ALE_MACPORT_TO_PORTMASK(ENET_MAC_PORT_" + i.toString() + ")";
            }
        }
    }

    alePortMask += ")";
    return alePortMask;
}

function getIpNxtWhitelistCount(instance) {
    return instance.IpNxtWhitelist.length;
}

function getIpNxtWhitelistInitArray(instance) {
    let whiteListInitArray;
    let whiteListInitArrayMapFunction = function(currentValue, index, arr)
                                        {
                                            return ("[" + index + "]" + " = " + currentValue);
                                        };
    whiteListInitArray = instance.IpNxtWhitelist.map(whiteListInitArrayMapFunction);

    return whiteListInitArray;
}

%%}


#include <include/per/cpsw.h>
#include <include/core/enet_dma.h>
#include "ti_drivers_config.h"
#include <utils/include/enet_apputils.h>
#include <include/core/enet_rm.h>
#include <utils/include/enet_appsoc.h>
#include "ti_enet_config.h"

% if(module.getDmaInterface(instance) == "ENET_SOC_HOSTPORT_DMA_TYPE_UDMA") {
#include <drivers/udma/udma_priv.h>
extern EnetDma_Cfg gDmaCfg;
%}
%else {
extern EnetDma_Cfg gDmaCfg;
%}

const EnetRm_ResCfg gEnetRmResCfg =
{
    .selfCoreId = `module.getCpuID()`,
    %let socName = common.getSocName();
    .resPartInfo =
    {
        %if ((socName == 'am62px'|| socName == 'am62dx' || socName == 'am62ax' || socName == 'am62x')) {
        .numCores = `module.getEnetResPartInfoNumCores(instance)`,
        .coreResInfo =
        {
            %var numCores = module.getEnetResPartInfoNumCores(instance);
            %for (var i = 0; i < numCores; i++){
            [`i`] =
            {
                %if (instance.IsEthFw){
                .numTxCh       = `module.getEnetResPartInfoNumTxCh(instance, i)`,
                .coreId        = `module.getEnetCoreResInfoCoreId(instance, i)`,
                .numRxFlows    = `module.getEnetCoreResInfoNumRxFlows(instance, i)`,
                %} else {
                .numTxCh       = ENET_SYSCFG_TX_CHANNELS_NUM,
                .coreId        = `module.getCpuID()`,
                .numRxFlows    = (ENET_SYSCFG_RX_FLOWS_NUM + 1),
                %}
                .numRxCh       = `module.getEnetCoreResInfoNumRxCh(instance, i)`,
                .numMacAddress = `module.getEnetCoreResInfoNumMac(instance, i)`,
                .numHwPush     = `module.getEnetCoreResInfoNumHwPush(instance, i)`,
            },
            %}
        },
        .isStaticTxChanAllocated = `module.getEnetResPartInfoIsStatTxChAlloc(instance)`,
        %}
        % else {
        .numCores = `module.getEnetResPartInfoNumCores()`,
        .coreResInfo =
        {
            %var numCores = module.getEnetResPartInfoNumCores();
            %for (var i = 0; i < numCores; i++){
            [`i`] =
            {
                .numTxCh       = ENET_SYSCFG_TX_CHANNELS_NUM,
                .numRxCh       = `module.getEnetCoreResInfoNumRxCh(i)`,
                .coreId        = `module.getCpuID()`,
                .numRxFlows    = (ENET_SYSCFG_RX_FLOWS_NUM + 1),
                .numMacAddress = `module.getEnetCoreResInfoNumMac(i)`,
                .numHwPush     = `module.getEnetCoreResInfoNumHwPush(i)`,

            },
            %}
        },
        .isStaticTxChanAllocated = `module.getEnetResPartInfoIsStatTxChAlloc()`,
        %}
    },
    .ioctlPermissionInfo =
    {
        .defaultPermittedCoreMask = 0xFFFFFFFFU,
        .numEntries = 0,
        .entry = {{0}}
    },
    .macList =
    {
        .numMacAddress = 0,
        .macAddress =
        {
            %for (var i = 0; i < 10; i++){
                [`i`] = {0, 0, 0, 0, 0, 0},
            %}
        }
    },
};

Cpsw_Cfg gEnetCpswCfg =
{
    .escalatePriorityLoadVal = CPSW_ESC_PRI_LD_VAL,
    .dmaCfg = &gDmaCfg,
    .vlanCfg =
    {
        .vlanAware = false,
        .vlanSwitch = ENET_VLAN_TAG_TYPE_INNER,
        .outerVlan = 0x88A8U,
        .innerVlan = 0x8100U,
    },
    .txMtu =
    {
        1536,
        1536,
        1536,
        1536,
        1536,
        1536,
        1536,
        1536
    },
    .hostPortCfg =
    {
        .crcType           = `instance.hostportCrcType`,
        .removeCrc         = `instance.hostportRemoveCrc`,
        .padShortPacket    = `instance.hostportPadShortPacket`,
        .passCrcErrors     = `instance.hostpostPassCrcErrors`,
        .rxMtu             = `instance.hostportRxMtu`,
        .passPriorityTaggedUnchanged = `instance.hostportPassPriorityTaggedUnchanged`,
        .rxCsumOffloadEn   = `instance.hostportRxCsumOffloadEn`,
        .txCsumOffloadEn   = `instance.hostportTxCsumOffloadEn`,
        .rxVlanRemapEn     = `instance.hostportRxVlanRemapEn`,
        .rxDscpIPv4RemapEn = `instance.hostporRxDscpIPv4RemapEn`,
        .rxDscpIPv6RemapEn = `instance.hostporRxDscpIPv6RemapEn`,
        .vlanCfg           =
        {
            .portPri = `instance.hostportPortPri`,
            .portCfi = `instance.hostportCfi`,
            .portVID = `instance.hostportPortVID`,
        },
        .rxPriorityType    = `instance.hostportRxPriorityType`,
        .txPriorityType    = `instance.hostportTxPriorityType`,
    },
    .aleCfg =
    {
        .modeFlags = `getAleModeFlags(module,instance)`,
        .policerGlobalCfg =
        {
            .policingEn = `instance.policingEn`,
            .yellowDropEn = `instance.yellowDropEn`,
            .redDropEn = `instance.redDropEn`,
            .yellowThresh = CPSW_ALE_POLICER_YELLOWTHRESH_`instance.yellowThresh`,
            .policerNoMatchMode = CPSW_ALE_POLICER_NOMATCH_MODE_`instance.policerNoMatchMode`,
            .noMatchPolicer =
            {
                .peakRateInBitsPerSec = `instance.UnregulatedTrafficPeakRateInBitsPerSec`,
                .commitRateInBitsPerSec = `instance.UnregulatedTrafficCommitedRateInBitsPerSec`
            }
        },
        .agingCfg =
        {
            .autoAgingEn = `instance.autoAgingEn`,
            .agingPeriodInMs = `instance.agingPeriodInMs`
        },
        .vlanCfg =
        {
            .aleVlanAwareMode   = `instance.aleVlanAwareMode`,
            .cpswVlanAwareMode  = `instance.cpswVlanAwareMode`,
            .autoLearnWithVlan  = `instance.autoLearnWithVlan`,
            .unknownVlanNoLearn = `instance.unknownVlanNoLearn`,
            .unknownForceUntaggedEgressMask = `getAlePortMask(instance,"unknownVlanForceUntaggedEgress")`,
            .unknownRegMcastFloodMask       = `getAlePortMask(instance,"unknownRegMcast")`,
            .unknownUnregMcastFloodMask     = `getAlePortMask(instance,"unknownUnregMcast")`,
            .unknownVlanMemberListMask      = `getAlePortMask(instance,"unknownVlanMembership")`,
        },
        .nwSecCfg =
        {
            .hostOuiNoMatchDeny  = `instance.hostOuiNoMatchDeny`,
            .vid0ModeEn          = `instance.vid0ModeEn`,
            .malformedPktCfg     = {
                                    .srcMcastDropDis = `instance.srcMcastDropDis`,
                                    .badLenPktDropEn = `instance.badLenPktDropEn`,
                                },
            .ipPktCfg            = {
                                    .dfltNoFragEn          = `instance.dfltNoFragEn`,
                                    .dfltNxtHdrWhitelistEn = `instance.dfltNxtHdrWhitelistEn`,
                                    .ipNxtHdrWhitelistCnt  =  `getIpNxtWhitelistCount(instance)`,
                                    .ipNxtHdrWhitelist     = {
                                                                `getIpNxtWhitelistInitArray(instance)`
                                                                },
                                },


            .macAuthCfg          = {
                                    .authModeEn           = `instance.authModeEn`,
                                    .macAuthDisMask       = `getAlePortMask(instance, "disableMacAuth")`,
                                },
        },
        .portCfg =
        {
            [CPSW_ALE_HOST_PORT_NUM] =
            {
                .learningCfg =
                {
                    .noLearn         = `instance.nolearn_hostPort`,
                    .noSaUpdateEn    = `instance.noSaUpdteEn_hostPort`,
                },
                .vlanCfg =
                {
                    .vidIngressCheck = `instance.vidIngressCheck_hostPort`,
                    .dropUntagged    = `instance.dropUntagged_hostPort`,
                    .dropDualVlan    = `instance.dropDualVlan_hostPort`,
                    .dropDoubleVlan  = `instance.dropDoubleVlan_hostPort`,
                },
                .macModeCfg =
                {
                    .macOnlyCafEn    = `instance.macOnlyCafEn_hostPort`,
                    .macOnlyEn       = `instance.macOnlyEn_hostPort`,
                },
                .pvidCfg =
                {
                    .vlanIdInfo      =
                    {
                        .vlanId   = `instance.vlanId_hostPort`,
                        .tagType  = `instance.tagType_hostPort`,
                    },
                    .vlanMemberList          = `getAlePortMask(instance,"vlanMemberList_hostPort_")`,
                    .unregMcastFloodMask     = `getAlePortMask(instance,"unregMcastFloodMask_hostPort_")`,
                    .regMcastFloodMask       = `getAlePortMask(instance,"regMcastFloodMask_hostPort_")`,
                    .forceUntaggedEgressMask = `getAlePortMask(instance,"forceUntaggedEgressMask_hostPort_")`,
                    .noLearnMask             = `getAlePortMask(instance,"noLearnMask_hostPort_")`,
                    .vidIngressCheck         = `instance.vidIngressCheck_hostPort`,
                    .limitIPNxtHdr           = `instance.limitIPNxtHdr_hostPort`,
                    .disallowIPFrag          = `instance.disallowIPFrag_hostPort`,
                },
            },
        %let numMacPorts = 8;
        % for (var i = 1; i <= numMacPorts; i ++) {
            %if ((instance.hasOwnProperty(`nolearn_macPort${i}`))) {
            [CPSW_ALE_MACPORT_TO_ALEPORT(ENET_MAC_PORT_`i`)] =
            {
                .learningCfg =
                {
                    .noLearn         = `instance["nolearn_macPort"+i]`,
                    .noSaUpdateEn    = `instance["noSaUpdteEn_macPort"+i]`,
                },
                .vlanCfg =
                {
                    .vidIngressCheck = `instance["vidIngressCheck_macPort"+i]`,
                    .dropUntagged    = `instance["dropUntagged_macPort"+i]`,
                    .dropDualVlan    = `instance["dropDualVlan_macPort"+i]`,
                    .dropDoubleVlan  = `instance["dropDoubleVlan_macPort"+i]`,
                },
                .macModeCfg =
                {
                    .macOnlyCafEn    = `instance["macOnlyCafEn_macPort"+i]`,
                    .macOnlyEn       = `instance["macOnlyEn_macPort"+i]`,
                },
                .pvidCfg =
                {
                    .vlanIdInfo      =
                    {
                        .vlanId   = `instance["vlanId_macPort"+i]`,
                        .tagType  = `instance["tagType_macPort"+i]`,
                    },
                    .vlanMemberList          = `getAlePortMask(instance,"vlanMemberList_macPort"+i+"_")`,
                    .unregMcastFloodMask     = `getAlePortMask(instance,"unregMcastFloodMask_macPort"+i+"_")`,
                    .regMcastFloodMask       = `getAlePortMask(instance,"regMcastFloodMask_macPort"+i+"_")`,
                    .forceUntaggedEgressMask = `getAlePortMask(instance,"forceUntaggedEgressMask_macPort"+i+"_")`,
                    .noLearnMask             = `getAlePortMask(instance,"noLearnMask_macPort"+i+"_")`,
                    .vidIngressCheck         = `instance["vidIngressCheck_macPort"+i]`,
                    .limitIPNxtHdr           = `instance["limitIPNxtHdr_macPort"+i]`,
                    .disallowIPFrag          = `instance["disallowIPFrag_macPort"+i]`,
                },
            },
            %}
        %}
        },
        .policerTablePartSize =
        {

        }
    },
    .cptsCfg =
    {
        .hostRxTsEn     = `instance.cptsHostRxTsEn`,
        .tsCompPolarity = `(instance.cptsTsCompPolarity === "ASSERT_HIGH") ? true : false`,
        .tsRxEventsDis  = `instance.cptsTsRxEventsDis`,
        .tsGenfClrEn    = `instance.cptstsGenfClrEn`,
        .cptsRftClkFreq = `instance.cptsRftClkFreq`,
    },
    .mdioCfg =
    {
        .mode               = `instance.mdioMode`,
        .mdioBusFreqHz      = `instance.mdioBusFreqHz`,
        .phyStatePollFreqHz = `enetutilsScript.getPhyStatePollFreqHz(instance.mdioBusFreqHz, instance.mdioIPGRatio)`,
        .pollEnMask         = `enetutilsScript.getArraytoBitMask(instance.mdioPollEnMask)`,
        .c45EnMask          = `enetutilsScript.getArraytoBitMask(instance.mdioC45EnMask)`,
        .isMaster           = `instance.mdioIsMaster`,
%if(instance.ExternalPhyMgmtEnable == true){
        .disableStateMachineOnInit = true,
%}
%else {
        .disableStateMachineOnInit = `instance.mdioDisableStateMachineOnInit`,
%}
    },
    .resCfg = gEnetRmResCfg,
    .intrPriority = 1U,
    .mdioLinkStateChangeCb = NULL,
    .mdioLinkStateChangeCbArg = NULL,
    .portLinkStatusChangeCb = NULL,
    .portLinkStatusChangeCbArg = NULL,
    .enableQsgmii0RDC = false,
    .enableQsgmii1RDC = false,
%if(instance.ExternalPhyMgmtEnable == true){
    .disablePhyDriver = true,
%}
%else {
    .disablePhyDriver = false,
%}
};

Cpsw_Cfg * EnetApp_getCpswCfg(const Enet_Type enetType, const uint32_t instId)
{
    Cpsw_Cfg * pCpswCfg = NULL;

    if(Enet_isCpswFamily(enetType))
    {
        pCpswCfg = &gEnetCpswCfg;
    }

    return pCpswCfg;
}

void EnetApp_cpswInitMacAddr(const Enet_Type enetType,
                          const uint32_t instId)
{
    int32_t status;
    Cpsw_Cfg * pCpswCfg = NULL;
    EnetRm_ResCfg *resCfg =NULL;
    pCpswCfg = EnetApp_getCpswCfg(enetType, instId);

    EnetAppUtils_assert(pCpswCfg != NULL);
    resCfg = &pCpswCfg->resCfg;
    EnetAppUtils_assert(resCfg != NULL);

    status = EnetAppSoc_getMacAddrList(enetType,
                                       instId,
                                       resCfg->macList.macAddress,
                                       &resCfg->macList.numMacAddress);
    EnetAppUtils_assert(status == ENET_SOK);
    if (resCfg->macList.numMacAddress > ENET_ARRAYSIZE(resCfg->macList.macAddress))
    {
        EnetAppUtils_print("EnetApp_cpswInitMacAddr: "
                           "Limiting number of mac address entries to resCfg->macList.macAddress size"
                           "Available:%u, LimitedTo: %u",
                           resCfg->macList.numMacAddress,
                           ENET_ARRAYSIZE(resCfg->macList.macAddress));
        resCfg->macList.numMacAddress = ENET_ARRAYSIZE(resCfg->macList.macAddress);
    }

    EnetAppUtils_updatemacResPart(&resCfg->resPartInfo,
                                  resCfg->macList.numMacAddress,
                                  resCfg->selfCoreId);
}